/*
=========================================================================

                            WinSpoutDirectX9.cpp

   A Windows Desktop Application project generated by Visual Studio
   Adapted for Spout input (http://spout.zeal.co/) using the SpoutDX support class

   -----------------------------------------------------------
  
   This is a DirectX 9 receiver using methods in SpoutDirectX.cpp
   demonstrating a D3D11 compute copy shader to receive from senders
   with formats other than BGRA

   Receives to a texture, applies a copy shader to change to default
   BGRA format, opens a shared texture handle from that texture,
   saves to a pixel buffer and displays the output using Windows bitmap
   functions in WM_PAINT. Refer to the "Render()" function for details.

   Shaders in "SpoutDX9shaders.hpp" are optional and enabled if the file exists
   in the same folder as the SpoutDirecX9 source files (see WinSpoutDirectX9.h).
   "__spoutDX9shaders__" is defined if the file is included.

   To build without shaders, rename or remove SpoutDX9shaders.hpp
   or simply comment out "#include "SpoutDX9shaders.hpp" in SpoutDirecX9.h
   For Visual Studio : "Project > Rescan Solution" and "Build > Rebuild Solution".
  
=========================================================================

                 Copyright(C) 2025 Lynn Jarvis.

This program is free software : you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.If not, see < http://www.gnu.org/licenses/>.
========================================================================

*/
#include "framework.h"
#include "WinSpoutDirectX9.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst = nullptr;              // current instance
WCHAR szTitle[MAX_LOADSTRING]{};        // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING]{};  // the main window class name

spoutDirectX9 spoutdx9;                  // DirectX9 functions  
spoutSenderNames spoutsender;            // Sender names
spoutFrameCount frame;                   // Frame count and fps
spoutCopy spoutcopy;                     // For pixel readback

HWND g_hWnd = nullptr;                   // Window handle
IDirect3D9Ex* g_pD3D = NULL;             // Used to create the D3D9Ex device
IDirect3DDevice9Ex* g_pd3dDevice = NULL; // D3D9Ex device
LPDIRECT3DTEXTURE9 g_pReceivedTexture = nullptr; // DirectX 9 received texture
LPDIRECT3DSURFACE9 g_pReadbackSurface = nullptr; // Surface for texure pixel readback

unsigned char *pixelBuffer = nullptr;   // Receiving pixel buffer
char g_SenderName[256]{};               // Received sender name
unsigned int g_SenderWidth = 0;         // Sender width
unsigned int g_SenderHeight = 0;        // Sender height
DWORD g_SenderFormat = 0;               // Sender format
double g_SenderFps = 0.0;               // For fps display averaging
bool bSpoutInitialized = false;         // Initialized for the connected sender
bool SelectSender(HWND hWnd = nullptr); // Select a sender
DWORD GetDX11format(char* sendername);  // Sender shared texture format (D3D11)

bool bShowInfo = true;                  // Show on-screen info
void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos);


// The following are specific to this application
// if spoutDXshaders is included (see WinSpoutDirecX9.h)
// to read pixel data from the D3D11 BGRA copy texture
#ifdef __spoutDX9shaders__
spoutDirectX spoutdx;
ID3D11Texture2D* m_pStaging = nullptr;
void GetCopyPixels(ID3D11Texture2D* pStaging, unsigned char* pixeldata);
#endif
// Read pixel data from the D3D9 received texture without shaders
bool GetTexturePixels(LPDIRECT3DTEXTURE9 pTexture, unsigned char* pixeldata);

// Forward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);

void ShowSenderInfo(HDC hdc); // Show sender information on screen
void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos); // Draw text

void Render();

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

	// Console for debugging
	OpenSpoutConsole();
	// EnableSpoutLog();

    // Initialize global strings
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_MENU, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow))
    {
        return FALSE;
    }

	// Initialize DirectX 9
	// A device is created in the SpoutDirectX9 class
	if (!spoutdx9.OpenDirectX9(g_hWnd)) // A window handle is required
		return FALSE;

	// Local D3D9 object and device
	g_pD3D = spoutdx9.GetDX9object();
	g_pd3dDevice = spoutdx9.GetDX9device();

	#ifdef __spoutDX9shaders__
	// Create shaders class D3D11 device
	spoutdx9.shaders.OpenDX11();
	// Force use of compute shader and copy texture even for
	// a compatible BGRA sender texture to enable efficient
	// copy to a pixel buffer for WM_PAINT
	spoutdx9.shaders.SetCopyTexture(true);
	#endif

    // Main message loop:
	MSG msg = { 0 };
	while (WM_QUIT != msg.message)
	{
		if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		// Always render
		Render();
	}

	#ifdef __spoutDX9shaders__
	// Close the shader D3D11 device
	spoutdx9.shaders.CloseDX11();
	// Release pixel buffer and staging texture used for WM_PAINT
	if (pixelBuffer) delete[] pixelBuffer;
	pixelBuffer = nullptr;
	if (m_pStaging) m_pStaging->Release();
	m_pStaging = nullptr;
	#endif

	// Release the copy of the sender's shared texture
	if (g_pReceivedTexture) g_pReceivedTexture->Release();
	g_pReceivedTexture = nullptr;

	// Close the named texture access mutex
	frame.CloseAccessMutex();

	// Close frame counting
	frame.CleanupFrameCount();

	// Close the SpoutDirectX9 class device
	spoutdx9.CloseDirectX9();
	g_pd3dDevice = nullptr;
	g_pD3D = nullptr;


    return (int) msg.wParam;
}

// Main render function
void Render()
{
	// Find if a sender exists.
	// Return the sender name, width, height, sharehandle and format.
	// For an empty name string, the active sender is returned if that exists.
	unsigned int width = 0;
	unsigned int height = 0;
	DWORD dwFormat = 0;
	HANDLE dxShareHandle = nullptr;
	if (spoutsender.FindSender(g_SenderName, width, height, dxShareHandle, dwFormat))
	{
		// Set up if not initialized yet
		if (!bSpoutInitialized) {
			// Open a named mutex to control access to the sender's shared texture
			frame.CreateAccessMutex(g_SenderName);
			// Optional frame counting to get the sender frame number and fps
			frame.EnableFrameCount(g_SenderName);
			bSpoutInitialized = true;
		}

		// Check for size or format change
		if (g_SenderWidth != width || g_SenderHeight != height || g_SenderFormat != dwFormat)
		{
			// Update globals
			g_SenderWidth = width;
			g_SenderHeight = height;
			g_SenderFormat = dwFormat;

			// Update the pixel buffer used for Windows paint
			if (pixelBuffer) delete[] pixelBuffer;
			unsigned int buffersize = g_SenderWidth * g_SenderHeight * 4;
			pixelBuffer = new unsigned char[buffersize];
			// Clear to dark grey
			memset(pixelBuffer, 32, g_SenderWidth * g_SenderHeight * 4);

			#ifdef __spoutDX9shaders__
			// Update the D3D11 staging texture for pixel copy
			// Use the shader class shader DX11 device for
			// subsequent copy from the shader class BGRA texture
			if (m_pStaging) m_pStaging->Release();
			m_pStaging = nullptr;
			spoutdx.CreateDX11StagingTexture(spoutdx9.shaders.GetDX11device(),
				g_SenderWidth, g_SenderHeight,
				DXGI_FORMAT_B8G8R8A8_UNORM, &m_pStaging);
			// Release shader resources to re-create for the new received texture
			spoutdx9.shaders.ReleaseShaderResources();
			#endif

		} // endif size or format change

		// Access the sender shared texture
		if (frame.CheckTextureAccess()) {

			// Check whether the sender has produced a new frame
			// to avoid un-necessary processing.
			if (frame.GetNewFrame()) {

				// Create a D3D9 texture from the D3D11 share handle

				// A sender format DXGI_FORMAT_B8G8R8A8_UNORM is required, but if
				// SpoutDX9shaders.hpp is available, other texture formats can be used.
				// The D3D11 sender texture is copied to a BGRA texture and a handle to
				// that used for "CreateTexture" instead of the original sender shared
				// texture handle. See spoutDirectX9::CreateSharedDX9Texture.
				// (The texture is released before re-create)
				spoutdx9.CreateSharedDX9Texture(g_pd3dDevice,
					width, height,
					D3DFMT_A8R8G8B8, // Format compatible with D3D11
					g_pReceivedTexture, // DirectX 9 copy of the sender shared texture
					dxShareHandle);

			} // Accessed sender shared texture

			// Allow texture access even if it was not a new frame
			frame.AllowTextureAccess();

		} // New frame

		// A DirectX 9 copy of the sender shared texture (g_pReceivedTexture)
		// has been updated by CreateSharedDX9Texture and can be used for
		// rendering or other purposes.

		// For this application, BGRA pixel data is required for WM_PAINT.
		// If shaders are availiable, the D3D11 BGRA copy texture can be used
		// to get the pixel buffer with D3D11 methods. This is slow but still
		// more efficient than pixel copy from the DirectX 9 texture
		#ifdef __spoutDX9shaders__
		GetCopyPixels(m_pStaging, pixelBuffer);
		#else
		// Get pixels from the received texture
		// Hesitations are more noticeable but it works for demonstration purposes
		GetTexturePixels(g_pReceivedTexture, pixelBuffer);
		#endif

	} // Sender exists
	else {
		// A sender was not found or the connected sender closed
		if (bSpoutInitialized) {
			// Zero the sender name to look for the active sender next time
			g_SenderName[0] = 0;
			// Close the named access mutex and frame counting
			frame.CloseAccessMutex();
			frame.CleanupFrameCount();
			// Zero globals to reset the D3D9 receiving texture,
			// D3D11 staging texture and pixel buffer
			g_SenderWidth = 0;
			g_SenderHeight = 0;
			g_SenderFormat = 0;
			// Initialize them again when a sender is found
			bSpoutInitialized = false;
		}
	}

	// Redraw immediately instead of waiting for a Windows paint message
	RedrawWindow(g_hWnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASENOW | RDW_INTERNALPAINT);

	// Hold a target frame rate
	// Render rate can be extremely high if graphics driver
	// "wait for vertical refresh" is disabled.
	frame.HoldFps(60);

}


#ifdef __spoutDX9shaders__
// Get pixels from the BGRA copy texture (used in
// shaders CopyDX11shareHandle) for WM_PAINT
void GetCopyPixels(ID3D11Texture2D* pStaging, unsigned char* pixeldata)
{
	// Shader class context for copy
	ID3D11DeviceContext* pImmediateContext = spoutdx9.shaders.GetDX11context();
	// Copy the shaders BGRA copy texture to the staging texture
	pImmediateContext->CopyResource(pStaging, spoutdx9.shaders.GetCopyTexture());
	// Map the staging texture resource to access the pixels
	D3D11_MAPPED_SUBRESOURCE mappedSubResource = {};
	// Make sure all commands are done before mapping the staging texture
	pImmediateContext->Flush();
	// Map waits for GPU access
	const HRESULT hr = pImmediateContext->Map(pStaging, 0, D3D11_MAP_READ, 0, &mappedSubResource);
	if (SUCCEEDED(hr)) {
		if (mappedSubResource.RowPitch == g_SenderWidth*4) {
			spoutcopy.memcpy_sse2(pixeldata, mappedSubResource.pData, g_SenderWidth*g_SenderHeight*4);
		}
		else {
			// Line by line for different pitch
			uint8_t* src = (uint8_t *)mappedSubResource.pData;
			for (UINT y = 0; y < g_SenderHeight; ++y) {
				spoutcopy.memcpy_sse2(pixeldata + y*g_SenderWidth*4,
					src + y*mappedSubResource.RowPitch, g_SenderWidth*4);
			}
		}
		pImmediateContext->Unmap(pStaging, 0);
	}
}
#endif

// Get pixels from the D3D9 received texture for WM_PAINT
bool GetTexturePixels(LPDIRECT3DTEXTURE9 pTexture, unsigned char* pixeldata)
{
	// Fails if the format is not BGRA
	if(!pTexture)
		return false;

	// Check for size change and readback surface update
	D3DSURFACE_DESC desc{};
	if(g_pReadbackSurface)
		g_pReadbackSurface->GetDesc(&desc);

	if (desc.Width == 0 || desc.Width != g_SenderWidth || desc.Height != g_SenderHeight) {
		if (g_pReadbackSurface)	g_pReadbackSurface->Release();
		g_pd3dDevice->CreateOffscreenPlainSurface(g_SenderWidth, g_SenderHeight,
			D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, &g_pReadbackSurface, nullptr);
	}

	// Get surface level 0 of the texture
	LPDIRECT3DSURFACE9 pSurface = nullptr;
	pTexture->GetSurfaceLevel(0, &pSurface);

	// Copy GPU texture to system memory
	g_pd3dDevice->GetRenderTargetData(pSurface, g_pReadbackSurface);
	pSurface->Release();

	// Read to pixel buffer
	D3DLOCKED_RECT lockedRect{};
	if (SUCCEEDED(g_pReadbackSurface->LockRect(&lockedRect, nullptr, D3DLOCK_READONLY))) {
		// Buffer must be BGRA and match D3DFMT_A8R8G8B8, width*height*4
		uint8_t* destBGRA = pixeldata;
		if (lockedRect.Pitch == (int)g_SenderWidth*4) {
			spoutcopy.memcpy_sse2(destBGRA, lockedRect.pBits, g_SenderWidth*g_SenderHeight*4);
		}
		else {
			// Line by line for different pitch
			uint8_t* src = (uint8_t *)lockedRect.pBits;
			for (UINT y = 0; y < g_SenderHeight; ++y)
				spoutcopy.memcpy_sse2(destBGRA + y*g_SenderWidth*4, src + y*lockedRect.Pitch, g_SenderWidth*4);
		}
		g_pReadbackSurface->UnlockRect();
	}
	return false;
}

//
// Open a sender selection dialog
//
bool SelectSender(HWND hWnd)
{
	// Create a list of senders "senderlist"
	std::vector<std::string> senderlist;
	int nSenders = spoutsender.GetSenderCount();
	if (nSenders > 0) {
		char sendername[256] {};
		for (int i = 0; i < nSenders; i++) {
			if (spoutsender.GetSender(i, sendername))
				senderlist.push_back(sendername);
		}
	}

	// Get the active sender index "selected",
	// the current combobox item for SpoutMessageBox 
	int selected = 0;
	char sendername[256]{};
	if (spoutsender.GetActiveSender(sendername))
		selected = spoutsender.GetSenderIndex(sendername);

	// Show the message box even if the list is empty
	// to make it clear that no senders are running.
	if (SpoutMessageBox(hWnd, NULL, "Select sender", MB_OKCANCEL, senderlist, selected) == IDOK && !senderlist.empty()) {

		std::string selectedname = senderlist[selected];

		// Different sender
		if (selectedname != g_SenderName) {

			// Set the selected sender as active for the next receive
			spoutsender.SetActiveSender(senderlist[selected].c_str());

			// Zero globals to reset the D3D9 receiving texture,
			// D3D11 staging texture and pixel buffer, to receive
			// from the new active sender
			g_SenderName[0] = 0;
			g_SenderWidth = 0;
			g_SenderHeight = 0;
			g_SenderFormat = 0;
		}
	}
	

	// Cancel or no senders
	return false;
}

//---------------------------------------------------------
// Function: GetDX11Format
// Get sender DirectX 11 texture format
DWORD GetDX11format(char* sendername)
{
	DWORD dwFormat = 0;
	if (sendername[0]) {
		SharedTextureInfo info;
		if (spoutsender.getSharedInfo(sendername, &info)) {
			dwFormat = (DWORD)info.format;
		}
	}
	return dwFormat;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICONDX));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
	wcex.hbrBackground  = CreateHatchBrush(HS_DIAGCROSS, RGB(192, 192, 192));
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_MENU);
    wcex.lpszClassName  = szWindowClass;
	wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_ICONDX));

    return RegisterClassExW(&wcex);
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

   // Create window
   RECT rc = { 0, 0, 640, 360 }; // Desired client size
   AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, TRUE); // Allow for menu
   HWND hWnd = CreateWindowW(szWindowClass,
	   szTitle,
	   WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_THICKFRAME,
	   CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance,
	   nullptr);

   if (!hWnd)
      return FALSE;

   // Centre the window on the desktop work area
   GetWindowRect(hWnd, &rc);
   RECT WorkArea;
   int WindowPosLeft = 0;
   int WindowPosTop = 0;
   SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
   WindowPosLeft += ((WorkArea.right  - WorkArea.left) - (rc.right - rc.left)) / 2;
   WindowPosTop  += ((WorkArea.bottom - WorkArea.top)  - (rc.bottom - rc.top)) / 2;
   MoveWindow(hWnd, WindowPosLeft, WindowPosTop, (rc.right - rc.left), (rc.bottom - rc.top), false);

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   g_hWnd = hWnd;
      
   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // Parse the menu selections:
            switch (wmId)
            {
				case IDM_ABOUT:
				{
					std::string str = "\n                          WinSpoutDirectX9\n\n";
					str += "           DirectX 9 image receiver Windows example\n";
					str += "             using SpoutDirectX9, SpoutSenderNames\n";
					str += "                   and SpoutFrameCount methods\n\n ";
					str += "  Receive from senders with texture formats other than BGRA\n";
					str += "    using a D3D11 copy shader with \"SpoutDX9shaders.hpp\"\n\n";

					str += "              Right mouse button    - select sender\n";
					str += "              Middle mouse button - image adjust\n\n";
					str += "                           <a href=\"https://spout.zeal.co\">https://spout.zeal.co</a>\n";
					HICON hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICONDX));
					SpoutMessageBoxIcon(hIcon);
					SpoutMessageBox(hWnd, str.c_str(), "About", MB_USERICON | MB_OK);
				}
                break;

				case IDM_OPEN:
				// Right mouse click to select a sender
				// Pass in hWnd to centre on the window
				// See also WM_RBUTTONDOWN
				SelectSender(hWnd);
				break;

			case IDM_EXIT:
                DestroyWindow(hWnd);
                break;

            default:
                return DefWindowProc(hWnd, message, wParam, lParam);

            } // end switch (wmId)

        } // endif WM_COMMAND
        break;

	case WM_KEYUP:
		{
			switch (wParam) {
				// 0x20 SPACEBAR
				case 0x20:
					bShowInfo = !bShowInfo;
					break;
				default:
					break;
			}
			break;

		}
		break;

    case WM_PAINT:
        {
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd, &ps);

			RECT dr ={0};
			GetClientRect(hWnd, &dr);
				
			// Create a double buffer so that both image and text
			// can be drawn o a memory DC to avoid flicker.
			HDC hdcMem = CreateCompatibleDC(hdc);
			int ndcmem = SaveDC(hdcMem);
			HBITMAP hbmMem = CreateCompatibleBitmap(hdc, (dr.right-dr.left), (dr.bottom-dr.top));
			SelectObject(hdcMem, hbmMem);

			//
			// Draw the received image
			//
			if (pixelBuffer) {

				// No sender - draw default background
				if (!bSpoutInitialized) {
					HBRUSH backbrush = CreateHatchBrush(HS_DIAGCROSS, RGB(192, 192, 192));
					FillRect(hdc, &dr, backbrush);
					DeleteObject(backbrush);
				}
				else {
					BITMAPINFO bmi{};
					bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
					bmi.bmiHeader.biSizeImage = (LONG)(g_SenderWidth*g_SenderHeight*4); // Pixel buffer size
					bmi.bmiHeader.biWidth = (LONG)g_SenderWidth;    // Width of buffer
					bmi.bmiHeader.biHeight = -(LONG)g_SenderHeight; // Height of buffer (bottom up)
					bmi.bmiHeader.biPlanes = 1;
					bmi.bmiHeader.biBitCount = 32;
					bmi.bmiHeader.biCompression = BI_RGB;

					// Draw into the memory DC
					// The received texture format is BGRA, compatible with StretchDIBits
					// StretchDIBits adapts the pixel buffer to the window size.
					// Setting the blit mode is necessary here
					SetStretchBltMode(hdcMem, STRETCH_DELETESCANS);
					StretchDIBits(hdcMem,
						0, 0, (dr.right - dr.left), (dr.bottom - dr.top),
						0, 0, g_SenderWidth, g_SenderHeight, pixelBuffer,
						&bmi, DIB_RGB_COLORS, SRCCOPY);

					// Draw information text
					if (bShowInfo)
						ShowSenderInfo(hdcMem);

					// Copy the double buffer to screen
					BitBlt(hdc, 0, 0, (dr.right-dr.left), (dr.bottom-dr.top), hdcMem, 0, 0, SRCCOPY);
					
					// Clean up
					RestoreDC(hdcMem, ndcmem);
					DeleteObject(hbmMem);
					DeleteDC(hdcMem);

				}
			}
			EndPaint(hWnd, &ps);
        }
        break;

	case WM_RBUTTONDOWN:
		// Right mouse click to select a sender
		// Pass in hWnd to centre on the window
		// (see also IDM_OPEN)
		SelectSender(g_hWnd);
		break;

	case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}


void ShowSenderInfo(HDC hdc)
{
	std::string str = "[";
	str += g_SenderName;
	str += "]  :  ";
	str += std::to_string(g_SenderWidth); str += "x";
	str += std::to_string(g_SenderHeight);
	
	// Sender texture format
	DWORD dwformat = GetDX11format(g_SenderName);
	str += "   ";
	// Formats can be :
	// 87 - DXGI_FORMAT_B8G8R8A8_UNORM (default)
	// 28 - DXGI_FORMAT_R8G8B8A8_UNORM
	// 24 - DXGI_FORMAT_R10G10B10A2_UNORM
	// 11 - DXGI_FORMAT_R16G16B16A16_UNORM
	// 10 - DXGI_FORMAT_R16G16B16A16_FLOAT
	// 02 - DXGI_FORMAT_R32G32B32A32_FLOAT
	switch (dwformat) {
		case 87: str += "8 bit BGRA";	break;
		case 28: str += "8 bit RGBA";	break;
		case 24: str += "10 bit RGBA";	break;
		case 11: str += "16 bit RGBA";	break;
		case 10: str += "16 bit RGBA float"; break;
		case 02: str += "32 bit RGBA float"; break;
	}

	// Show sender fps and framecount if selected
	if (frame.GetSenderFrame() > 0) {
		str += "   fps  ";
		// Average to stabilise fps display
		g_SenderFps = g_SenderFps*.85 + 0.15*frame.GetSenderFps();
		// Round first or integer cast will truncate to the whole part
		str += std::to_string((int)(round(g_SenderFps)));
		str += "   frame  ";
		str += std::to_string(frame.GetSenderFrame());
	}
	// White text (can be any colour (00 BB GG RR) hex)
	DrawString(str, hdc, 0x00FFFFFF, 20, 20);

	#ifdef __spoutDX9shaders__
	// GPU shader time
	str = "Copy  ";
	str += std::to_string(spoutdx9.shaders.GetGPUtimer());
	// truncate to 3 decimal places
	str = str.substr(0, str.rfind(".")+4);
	str += "  msec";

	// GPU usage
	if (spoutdx9.shaders.GetGPUlatestUsage() > 0.0) {
		str += "   GPU usage  ";
		str += std::to_string(spoutdx9.shaders.GetGPUlatestUsage());
		str = str.substr(0, str.rfind(".") + 2); // 2 decimal places
		str += " %";
		if (spoutdx9.shaders.GetGPUrecovery() > 0.0) {
			str += "  Excess at ";
			str += std::to_string(spoutdx9.shaders.GetGPUpeakUsage());
			str = str.substr(0, str.rfind(".") + 2);
			str += " %";
			str += "  Waiting for ";
			str += std::to_string(spoutdx9.shaders.GetGPUrecovery());
			str = str.substr(0, str.rfind(".") + 2);
			str += " %";
		}
		DrawString(str, hdc, 0x00FFFFFF, 20, 40);
	}
	#else
	if (dwformat != 87) {
		str = "Sender format not compatible";
		DrawString(str, hdc, 0x00FFFFFF, 20, 45);
	}
	#endif

	RECT rc{};
	GetClientRect(g_hWnd, &rc);
	str = "Right button - select sender  :  Space - hide info";
	DrawString(str, hdc, 0x00FFFFFF, 20, rc.bottom-35);

}

void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos)
{
	HFONT hFont, hOldFont;
	hFont = (HFONT)GetStockObject(SYSTEM_FONT);
	if (hFont) {
		hOldFont = (HFONT)SelectObject(hdc, hFont);
		if (hOldFont) {
			// Text colour
			COLORREF oldText = SetTextColor(hdc, col);
			// Transparent background
			SetBkMode(hdc, TRANSPARENT);
			// Display the text string
			TextOutA(hdc, xpos, ypos, str.c_str(), (int)str.length());
			SetTextColor(hdc, oldText);
			SelectObject(hdc, hOldFont);
			DeleteObject(hOldFont);
		}
		DeleteObject(hFont);
	}
} // end text draw


// That's all..
