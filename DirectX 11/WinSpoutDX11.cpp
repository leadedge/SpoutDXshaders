/*
=========================================================================

                        WinSpoutDX11.cpp

   A Windows Desktop Application project generated by Visual Studio
   Adapted for Spout input (http://spout.zeal.co/) using the SpoutDX support class

   This is a receiver using SpoutDX demonstrating D3D11 compute shaders

   Shaders in "SpoutDXshaders.hpp" are enabled if the file exists.
   For this example, in the same folder as the SpoutDX source files
   (see WinSpoutDX11.h).

   Receives to a texture, applies shaders, saves to a pixel buffer
   and displays the output using Windows bitmap functions in WM_PAINT.

=========================================================================

                 Copyright(C) 2025 Lynn Jarvis.

This program is free software : you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.If not, see < http://www.gnu.org/licenses/>.
========================================================================

*/
#include "framework.h"
#include "WinSpoutDX11.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst = nullptr;              // current instance
WCHAR szTitle[MAX_LOADSTRING]{};        // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING]{};  // the main window class name

spoutDX receiver;                           // Receiver object
HWND g_hWnd = nullptr;                      // Window handle
ID3D11Texture2D* receivedTexture = nullptr; // Receiving texture
unsigned char *pixelBuffer = nullptr;       // Receiving pixel buffer
unsigned char g_SenderName[256]{};          // Received sender name
unsigned int g_SenderWidth = 0;             // Sender width
unsigned int g_SenderHeight = 0;            // Sender height
DWORD g_SenderFormat = 0;                   // Sender format
double g_SenderFps = 0.0;                   // For fps display averaging
bool SelectSender(HWND hWnd = nullptr);     // Select a sender
void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos);
bool bShowInfo = true;                      // Show on-screen info

// Forward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);

void ShowSenderInfo(HDC hdc); // Show sender information on screen
void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos); // Draw text

// Message handler for modeless Image Adjust dialog
LRESULT CALLBACK UserAdjust(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void SaveAdjust(); // Save old values
void RestoreAdjust(); // Restore globals from old values
void ResetAdjust(); // Reset values to defaults
void SetupDialogControls(HWND hDlg); // Reset dialog controls
static HWND hwndAdjust = NULL;

// Variables for the dialog
float Brightness  = 0.0f;
float Contrast    = 1.0f;
float Saturation  = 1.0f;
float Gamma       = 1.0f;
float Temp        = 6500.0f; // daylight
float Blur        = 0.0f;
float Sharpness   = 0.0f;
float Sharpwidth  = 3.0f; // 3x3, 5x5, 7x7
static bool bAdaptive    = false; // CAS adaptive sharpen
static bool bFlip        = false;
static bool bMirror      = false;
static bool bSwap        = false;
// Old values for restore
float OldBrightness = 0.0f;
float OldContrast   = 1.0f;
float OldSaturation = 1.0f;
float OldGamma      = 1.0f;
float OldTemp       = 6500.0f;
float OldBlur       = 0.0f;
float OldSharpness  = 0.0f;
float OldSharpwidth = 3.0f;
bool OldAdaptive    = false;
bool OldFlip        = false;
bool OldMirror      = false;
bool OldSwap        = false;

void Render();

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

	// Console for debugging
	// OpenSpoutConsole();
	// EnableSpoutLog();

    // Initialize global strings
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_MENU, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow))
    {
        return FALSE;
    }

	// Initialize DirectX
	// A device is created in the SpoutDX class.
	if (!receiver.OpenDirectX11())
		return FALSE;

    // Main message loop:
	MSG msg = { 0 };
	while (WM_QUIT != msg.message)
	{
		if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		// Always render
		Render();
	}

	// Release pixel buffer used for WM_PAINT
	if (pixelBuffer) delete[] pixelBuffer;

	// Release the receiver
	receiver.ReleaseReceiver();

	// Release DirectX 11 device and context
	receiver.CloseDirectX11();

    return (int) msg.wParam;
}

// Main render function
void Render()
{
	// Get a texture from the sender for shader processing
	if (receiver.ReceiveTexture()) {

		// IsUpdated() returns true if the sender has changed
		if (receiver.IsUpdated()) {

			printf("Updated\n");

			// Update globals used for convenience throughout
			strcpy_s((char *)g_SenderName, 256, receiver.GetSenderName());
			g_SenderWidth = receiver.GetSenderWidth();
			g_SenderHeight = receiver.GetSenderHeight();
			g_SenderFormat = (DWORD)receiver.GetSenderFormat();

			// Update the pixel buffer for Window paint
			if(pixelBuffer)	delete[] pixelBuffer;
			unsigned int buffersize = g_SenderWidth*g_SenderHeight*4;
			pixelBuffer = new unsigned char[buffersize];

			// If SpoutDXshaders.hpp is included (see WinSpoutDX11.h)
			#ifdef __spoutDXshaders__

			// Update the local received texture
			// In this example it is BGRA format, compatible with WM_PAINT
			if (receivedTexture) receivedTexture->Release();
			receivedTexture = nullptr;
			// Create with unordered access view (UAV) for a shader destination texture.
			// The texture can also be read/write
			shaders.CreateDX11Texture(receiver.GetDX11Device(),
				g_SenderWidth, g_SenderHeight,
				DXGI_FORMAT_B8G8R8A8_UNORM, // BGRA format for Windows paint
				D3D11_USAGE_DEFAULT,
				0, // CPU flags - no access
				D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS,
				0, // Misc flags - not shared
				&receivedTexture);

			// Update shader resources to use the new textures
			shaders.UpdateResources(receiver.GetDX11Device(), receiver.GetDX11Context(),
				receivedTexture, receiver.GetSenderTexture());

			#else
				// Update the local received texture
				if (receivedTexture) receivedTexture->Release();
				receiver.CreateDX11texture(receiver.GetDX11Device(),
					g_SenderWidth, g_SenderHeight,
					receiver.GetSenderFormat(),
					&receivedTexture);
			#endif

			// Return to receive a new texture
			return;

		} // updated

		//
		// The sender shared texture has been updated
		//

		// If SpoutDXshaders.hpp is included (see WinSpoutDX11.h)
		#ifdef __spoutDXshaders__

		// Copy the sender shared texture to a local texture
		// The local texture is BGRA format for Windows paint
		// The sender texture format can be :
		//    DXGI_FORMAT_B8G8R8A8_UNORM
		//    DXGI_FORMAT_R8G8B8A8_UNORM
		//    DXGI_FORMAT_R10G10B10A2_UNORM
		//    DXGI_FORMAT_R16G16B16A16_FLOAT
		//    DXGI_FORMAT_R16G16B16A16_UNORM
		//    DXGI_FORMAT_R32G32B32A32_FLOAT
		shaders.Copy(receivedTexture,            // dest texture (uav)
					receiver.GetSenderTexture(), // source texture (srv)
					DXGI_FORMAT_B8G8R8A8_UNORM,  // dest format
					receiver.GetSenderFormat(),  // Source format
					g_SenderWidth, g_SenderHeight);

		//
		// Shaders have source and destination textures
		// The source texture can also be the destination
		//
		// Blur and sharpen use the sender texture as source
		// and should be used before the shaders that operate
		// only on the received texture.
		//
		// Format, width and height are the same for source and destination
		//

		// Blur 0 - 8  (default 0)
		if (Blur > 0.0f) {
			shaders.Blur(receivedTexture, // dest texture
				receiver.GetSenderTexture(), // source texture
				DXGI_FORMAT_B8G8R8A8_UNORM, // dest format
				g_SenderWidth, g_SenderHeight, Blur);
		}

		// Sharpness 0 - 1  (default 0)
		if (Sharpness > 0.0f) {
			if (bAdaptive) {
				// Sharpness width radio buttons
				// 3x3, 5x5, 7x7 : 3.0, 5.0, 7.0
				float caswidth = 1.0f + (Sharpwidth - 3.0f) / 2.0f; // 1.0, 2.0, 3.0
				// Sharpness; // 0.0 - 1.0
				shaders.AdaptiveSharpen(receivedTexture, // dest texture
						receiver.GetSenderTexture(), // source texture
						DXGI_FORMAT_B8G8R8A8_UNORM, // dest format
						g_SenderWidth, g_SenderHeight,
						caswidth, Sharpness);
			}
			else {
				shaders.Sharpen(receivedTexture, // dest texture
								receiver.GetSenderTexture(), // source texture
								DXGI_FORMAT_B8G8R8A8_UNORM, // dest format
								g_SenderWidth, g_SenderHeight,
								Sharpwidth, Sharpness);
			}
		}

		// Brightness    -1 - 1   default 0
		// Contrast       0 - 4   default 1
		// Saturation     0 - 4   default 1
		// Gamma          0 - 4   default 1
		if (Brightness != 0.0f || Contrast != 1.0f || Saturation != 1.0f || Gamma != 1.0f) {

			shaders.Adjust(receivedTexture, // source/dest texture
						   DXGI_FORMAT_B8G8R8A8_UNORM, // BGRA source format
						   g_SenderWidth, g_SenderHeight,
						   Brightness, Contrast, Saturation, Gamma);
		}

		// Temperature : 3500 - 9500  (default 6500 daylight)
		if (Temp != 6500.0f)
			shaders.Temperature(receivedTexture, DXGI_FORMAT_B8G8R8A8_UNORM, g_SenderWidth, g_SenderHeight, Temp);

		if (bFlip)
			shaders.Flip(receivedTexture, DXGI_FORMAT_B8G8R8A8_UNORM, g_SenderWidth, g_SenderHeight);

		if (bMirror)
			shaders.Mirror(receivedTexture, DXGI_FORMAT_B8G8R8A8_UNORM, g_SenderWidth, g_SenderHeight);
		
		if (bSwap)
			shaders.Swap(receivedTexture, DXGI_FORMAT_B8G8R8A8_UNORM, g_SenderWidth, g_SenderHeight);

		// Read the shader result to a pixel buffer for display
		receiver.ReadTexurePixels(receivedTexture, pixelBuffer);

		#else
		// Read the sender shared texture to a pixel buffer for display
		receiver.ReadTexurePixels(receiver.GetSenderTexture(), pixelBuffer);
		#endif

		// Invalidate the window to trigger WM_PAINT
		InvalidateRect(g_hWnd, NULL, FALSE);
		UpdateWindow(g_hWnd); // Update immediately
	} 

	// Optionally hold a target frame rate - e.g. 60 or 30fps.
	// This is not necessary if the application already has
	// fps control. But in this example, rendering is done
	// during idle time and render rate can be extremely high
	// if graphics driver "wait for vertical refresh" is disabled.
	receiver.HoldFps(60);

}

//
// Open a sender selection dialog
//
bool SelectSender(HWND hWnd)
{
	// Create a list of senders "senderlist"
	std::vector<std::string> senderlist;
	int nSenders = receiver.GetSenderCount();
	if (nSenders > 0) {
		char sendername[256] {};
		for (int i = 0; i < nSenders; i++) {
			if (receiver.GetSender(i, sendername))
				senderlist.push_back(sendername);
		}
	}

	// Get the active sender index "selected",
	// the current combobox item for SpoutMessageBox 
	int selected = 0;
	char sendername[256]{};
	if (receiver.GetActiveSender(sendername))
		selected = receiver.GetSenderIndex(sendername);

	// Show the message box even if the list is empty
	// to make it clear that no senders are running.
	if (SpoutMessageBox(hWnd, NULL, "Select sender", MB_OKCANCEL, senderlist, selected) == IDOK && !senderlist.empty()) {
		// release the receiver to receive from a new active sender
		receiver.ReleaseReceiver();
		// Set the selected sender as active for the next receive
		receiver.SetActiveSender(senderlist[selected].c_str());
	}
	// Cancel or no senders
	return false;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICONDX));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
	wcex.hbrBackground  = CreateHatchBrush(HS_DIAGCROSS, RGB(192, 192, 192));
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_MENU);
    wcex.lpszClassName  = szWindowClass;
	wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_ICONDX));

    return RegisterClassExW(&wcex);
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

   // Create window
   RECT rc = { 0, 0, 640, 360 }; // Desired client size
   AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, TRUE); // Allow for menu
   HWND hWnd = CreateWindowW(szWindowClass,
	   szTitle,
	   WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_THICKFRAME,
	   CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance,
	   nullptr);

   if (!hWnd)
      return FALSE;

   // Centre the window on the desktop work area
   GetWindowRect(hWnd, &rc);
   RECT WorkArea;
   int WindowPosLeft = 0;
   int WindowPosTop = 0;
   SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
   WindowPosLeft += ((WorkArea.right  - WorkArea.left) - (rc.right - rc.left)) / 2;
   WindowPosTop  += ((WorkArea.bottom - WorkArea.top)  - (rc.bottom - rc.top)) / 2;
   MoveWindow(hWnd, WindowPosLeft, WindowPosTop, (rc.right - rc.left), (rc.bottom - rc.top), false);

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   g_hWnd = hWnd;
      
   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // Parse the menu selections:
            switch (wmId)
            {
				case IDM_ABOUT:
				{
					std::string str = "\n                        WinSpoutDX\n\n";
					str += "      Spout image receiver Windows example\n";
					str += "Using D3D11 shaders with \"SpoutDXshaders.hpp\"\n";
					str += "      Right mouse button    - select sender\n";
					str += "      Middle mouse button - image adjust\n\n";
					str += "                   <a href=\"https://spout.zeal.co\">https://spout.zeal.co</a>\n";
					HICON hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICONDX));
					SpoutMessageBoxIcon(hIcon);
					SpoutMessageBox(hWnd, str.c_str(), "About", MB_USERICON | MB_OK);
				}
                break;

				case IDM_OPEN:
				// Right mouse click to select a sender
				// Pass in hWnd to centre on the window
				// See also WM_RBUTTONDOWN
				SelectSender(hWnd);
				break;

				case IDM_ADJUST:
				// Image Adjust dialog (see also WM_MBUTTONDOWN)
				if (receiver.IsConnected()) {
					if (!hwndAdjust) {
						SaveAdjust(); // Save current global values
						hwndAdjust = CreateDialogA(hInst, MAKEINTRESOURCEA(IDD_ADJUSTBOX), g_hWnd, (DLGPROC)UserAdjust);
					}
					else {
						SendMessageA(hwndAdjust, WM_DESTROY, 0, 0L);
						hwndAdjust = NULL;
					}
				}
				break;

			case IDM_EXIT:
                DestroyWindow(hWnd);
                break;

            default:
                return DefWindowProc(hWnd, message, wParam, lParam);

            } // end switch (wmId)

        } // endif WM_COMMAND
        break;

	case WM_KEYUP:
		{
			switch (wParam) {
				// 0x20 SPACEBAR
				case 0x20:
					bShowInfo = !bShowInfo;
					break;
				default:
					break;
			}
			break;

		}
		break;

    case WM_PAINT:
        {
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd, &ps);

			RECT dr ={0};
			GetClientRect(hWnd, &dr);
				
			// Create a double buffer so that both image and text
			// can be drawn o a memory DC to avoid flicker.
			HDC hdcMem = CreateCompatibleDC(hdc);
			int ndcmem = SaveDC(hdcMem);
			HBITMAP hbmMem = CreateCompatibleBitmap(hdc, (dr.right-dr.left), (dr.bottom-dr.top));
			SelectObject(hdcMem, hbmMem);

			//
			// Draw the received image
			//
			if (pixelBuffer) {

				// No sender - draw default background
				if (!receiver.IsConnected()) {
					HBRUSH backbrush = CreateHatchBrush(HS_DIAGCROSS, RGB(192, 192, 192));
					FillRect(hdc, &dr, backbrush);
					DeleteObject(backbrush);
				}
				else {
					BITMAPINFO bmi{};
					bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
					bmi.bmiHeader.biSizeImage = (LONG)(g_SenderWidth*g_SenderHeight*4); // Pixel buffer size
					bmi.bmiHeader.biWidth = (LONG)g_SenderWidth;    // Width of buffer
					bmi.bmiHeader.biHeight = -(LONG)g_SenderHeight; // Height of buffer (bottom up)
					bmi.bmiHeader.biPlanes = 1;
					bmi.bmiHeader.biBitCount = 32;
					bmi.bmiHeader.biCompression = BI_RGB;

					// Draw into the memory DC
					// The received texture format is BGRA, compatible with StretchDIBits
					// StretchDIBits adapts the pixel buffer to the window size.
					// Setting the blit mode is necessary here
					SetStretchBltMode(hdcMem, STRETCH_DELETESCANS);
					StretchDIBits(hdcMem,
						0, 0, (dr.right - dr.left), (dr.bottom - dr.top),
						0, 0, g_SenderWidth, g_SenderHeight, pixelBuffer,
						&bmi, DIB_RGB_COLORS, SRCCOPY);

					// Draw information text
					if (bShowInfo)
						ShowSenderInfo(hdcMem);

					// Copy the double buffer to screen
					BitBlt(hdc, 0, 0, (dr.right-dr.left), (dr.bottom-dr.top), hdcMem, 0, 0, SRCCOPY);
					
					// Clean up
					RestoreDC(hdcMem, ndcmem);
					DeleteObject(hbmMem);
					DeleteDC(hdcMem);

				}
			}
			EndPaint(hWnd, &ps);
        }
        break;

	case WM_RBUTTONDOWN:
		// Right mouse click to select a sender
		// Pass in hWnd to centre on the window
		// (see also IDM_OPEN)
		SelectSender(g_hWnd);
		break;

	case WM_MBUTTONDOWN:
		// Image Adjust dialog
		if (receiver.IsConnected()) {
			if (!hwndAdjust) {
				SaveAdjust(); // Save current global values
				hwndAdjust = CreateDialogA(hInst, MAKEINTRESOURCEA(IDD_ADJUSTBOX), g_hWnd, (DLGPROC)UserAdjust);
			}
			else {
				SendMessageA(hwndAdjust, WM_DESTROY, 0, 0L);
				hwndAdjust = NULL;
			}
		}
		break;

	case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}


void ShowSenderInfo(HDC hdc)
{
	std::string str = "[";
	str += receiver.GetSenderName();
	str += "]  :  ";
	str += std::to_string(receiver.GetWidth()); str += "x";
	str += std::to_string(receiver.GetHeight());

	// Sender texture format
	DWORD dwformat = receiver.GetSenderFormat();
	str += "   ";
	// Formats can be :
	// 87 - DXGI_FORMAT_B8G8R8A8_UNORM (default)
	// 28 - DXGI_FORMAT_R8G8B8A8_UNORM
	// 24 - DXGI_FORMAT_R10G10B10A2_UNORM
	// 11 - DXGI_FORMAT_R16G16B16A16_UNORM
	// 10 - DXGI_FORMAT_R16G16B16A16_FLOAT
	// 02 - DXGI_FORMAT_R32G32B32A32_FLOAT
	switch (dwformat) {
		case 87: str += "8 bit BGRA";	break;
		case 28: str += "8 bit RGBA";	break;
		case 24: str += "10 bit RGBA";	break;
		case 11: str += "16 bit RGBA";	break;
		case 10: str += "16 bit RGBA float"; break;
		case 02: str += "32 bit RGBA float"; break;
	}

	// Show sender fps and framecount if selected
	if (receiver.GetFrame() > 0) {
		str += "   fps ";
		// Average to stabilise fps display
		g_SenderFps = g_SenderFps*.85 + 0.15*receiver.GetSenderFps();
		// Round first or integer cast will truncate to the whole part
		str += std::to_string((int)(round(g_SenderFps)));
		str += "   frame  ";
		str += std::to_string(receiver.GetFrame());
	}
	// White text (can be any colour (00 BB GG RR) hex)
	// e.g. red = 0x000000FF
	DrawString(str, hdc, 0x00FFFFFF, 20, 20);

	RECT rc{};
	GetClientRect(g_hWnd, &rc);
	str = "Right button - select sender  :  Middle - image adjust  :  Space - hide info";
	DrawString(str, hdc, 0x00FFFFFF, 20, rc.bottom-35);

}

void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos)
{
	HFONT hFont, hOldFont;
	hFont = (HFONT)GetStockObject(SYSTEM_FONT);
	if (hFont) {
		hOldFont = (HFONT)SelectObject(hdc, hFont);
		if (hOldFont) {
			// Text colour
			COLORREF oldText = SetTextColor(hdc, col);
			// Transparent background
			SetBkMode(hdc, TRANSPARENT);
			// Display the text string
			TextOutA(hdc, xpos, ypos, str.c_str(), (int)str.length());
			SetTextColor(hdc, oldText);
			SelectObject(hdc, hOldFont);
			DeleteObject(hOldFont);
		}
		DeleteObject(hFont);
	}
} // end text draw


//
// Message handler for the Image Adjust dialog
//
LRESULT CALLBACK UserAdjust(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	char str1[MAX_PATH]{};
	HWND hBar = NULL;
	LRESULT iPos = 0;
	float fValue = 0.0f;
	RECT wrect{};
	RECT drect{};
	int x = 0;
	int y = 0;

	switch (message) {

	case WM_INITDIALOG:

		// Position to the left of the application window centre
		GetWindowRect(g_hWnd, &wrect);
		GetWindowRect(hDlg, &drect);
		x = wrect.left-(drect.right-drect.left);
		// If too far left, centre on the window
		if (x < 0)
			x = wrect.left+((wrect.right-wrect.left)-(drect.right-drect.left))/2;
		y = wrect.top+((wrect.bottom-wrect.top)-(drect.bottom-drect.top))/2;
		SetWindowPos(hDlg, NULL, x, y, 0, 0, SWP_NOSIZE);
		// Set up trackbars and checkboxes
		SetupDialogControls(hDlg);		
		return TRUE;

	// Trackbars
	// https://msdn.microsoft.com/en-us/library/windows/desktop/hh298416(v=vs.85).aspx
	case WM_HSCROLL:
		hBar = (HWND)lParam;
		if (hBar == GetDlgItem(hDlg, IDC_BRIGHTNESS)) {
			// 0 - 200 > -1 - +1
			iPos = SendMessage(hBar, TBM_GETPOS, 0, 0);
			fValue = ((float)iPos/200.0f)-1.0f;
			Brightness = fValue;
			sprintf_s(str1, 256, "%.3f", fValue);
			SetDlgItemTextA(hDlg, IDC_BRIGHTNESS_TEXT, (LPCSTR)str1);
		}
		else if (hBar == GetDlgItem(hDlg, IDC_CONTRAST)) {
			//  0 - 1 - 4 default 1
			iPos = SendMessage(hBar, TBM_GETPOS, 0, 0);
			fValue = ((float)iPos/100.0f);
			Contrast = fValue;
			sprintf_s(str1, 256, "%.3f", fValue);
			SetDlgItemTextA(hDlg, IDC_CONTRAST_TEXT, (LPCSTR)str1);
		}
		else if (hBar == GetDlgItem(hDlg, IDC_SATURATION)) {
			iPos = SendMessage(hBar, TBM_GETPOS, 0, 0);
			fValue = ((float)iPos)/100.0f;
			Saturation = fValue;
			sprintf_s(str1, 256, "%.3f", fValue);
			SetDlgItemTextA(hDlg, IDC_SATURATION_TEXT, (LPCSTR)str1);
		}
		else if (hBar == GetDlgItem(hDlg, IDC_GAMMA)) {
			iPos = SendMessage(hBar, TBM_GETPOS, 0, 0);
			fValue = ((float)iPos)/100.0f;
			Gamma = fValue;
			sprintf_s(str1, 256, "%.3f", fValue);
			SetDlgItemTextA(hDlg, IDC_GAMMA_TEXT, (LPCSTR)str1);
		}
		else if (hBar == GetDlgItem(hDlg, IDC_TEMPERATURE)) {
			iPos = SendMessage(hBar, TBM_GETPOS, 0, 0);
			fValue = ((float)iPos);
			Temp = fValue;
			sprintf_s(str1, 256, "%4.0f", fValue);
			SetDlgItemTextA(hDlg, IDC_TEMPERATURE_TEXT, (LPCSTR)str1);
		}
		else if (hBar == GetDlgItem(hDlg, IDC_SHARPNESS)) {
			if (Blur == 0.0f) {
				// Sharpen if blur is not set
				iPos = SendMessage(hBar, TBM_GETPOS, 0, 0);
				fValue = ((float)iPos) / 100.0f;
				Sharpness = fValue;
				sprintf_s(str1, 256, "%.3f", fValue);
				SetDlgItemTextA(hDlg, IDC_SHARPNESS_TEXT, (LPCSTR)str1);
			}
			else {
				// Set blur to zero
				Blur = 0.0f;
				sprintf_s(str1, 256, "%.3f", Blur);
				SetDlgItemTextA(hDlg, IDC_BLUR_TEXT, (LPCSTR)str1);
				SendMessage(GetDlgItem(hDlg, IDC_BLUR), TBM_SETPOS, 1, 0);
			}
		}
		else if (hBar == GetDlgItem(hDlg, IDC_BLUR)) {
			if (Sharpness == 0.0f) {
				// Blur if sharpen is not set
				iPos = SendMessage(hBar, TBM_GETPOS, 0, 0);
				fValue = ((float)iPos) / 100.0f;
				Blur = fValue;
				sprintf_s(str1, 256, "%.3f", fValue);
				SetDlgItemTextA(hDlg, IDC_BLUR_TEXT, (LPCSTR)str1);
			}
			else {
				// Set sharpen to zero
				Sharpness = 0.0f;
				sprintf_s(str1, 256, "%.3f", Sharpness);
				SetDlgItemTextA(hDlg, IDC_SHARPNESS_TEXT, (LPCSTR)str1);
				SendMessage(GetDlgItem(hDlg, IDC_SHARPNESS), TBM_SETPOS, 1, 0);
			}
		}
		break;

	case WM_DESTROY:
		DestroyWindow(hwndAdjust);
		hwndAdjust = NULL;
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {

		case IDC_SHARPNESS_3x3:
			Sharpwidth = 3.0;
			break;
		case IDC_SHARPNESS_5x5:
			Sharpwidth = 5.0;
			break;
		case IDC_SHARPNESS_7x7:
			Sharpwidth = 7.0;
			break;

		case IDC_ADAPTIVE:
			if (IsDlgButtonChecked(hDlg, IDC_ADAPTIVE) == BST_CHECKED)
				bAdaptive = true;
			else
				bAdaptive = false;
			break;

		case IDC_FLIP:
			if (IsDlgButtonChecked(hDlg, IDC_FLIP) == BST_CHECKED)
				bFlip = true;
			else
				bFlip = false;
			break;

		case IDC_MIRROR:
			if (IsDlgButtonChecked(hDlg, IDC_MIRROR) == BST_CHECKED)
				bMirror = true;
			else
				bMirror = false;
			break;

		case IDC_SWAP:
			if (IsDlgButtonChecked(hDlg, IDC_SWAP) == BST_CHECKED)
				bSwap = true;
			else
				bSwap = false;
			break;

		case IDC_RESTORE:
			// Restore from opening values
			RestoreAdjust();
			SetupDialogControls(hDlg);
			break;

		case IDC_RESET:
			// Reset to defaults
			ResetAdjust();
			SetupDialogControls(hDlg);
			break;

		case IDOK:
			// Save current values
			SaveAdjust();
			DestroyWindow(hwndAdjust);
			hwndAdjust = NULL;
			return TRUE;

		case IDCANCEL:
			// Restore from opening values
			RestoreAdjust();
			DestroyWindow(hwndAdjust);
			hwndAdjust = NULL;
			return TRUE;

		default:
			return FALSE;
		}
		break;

	}

	return FALSE;
}

// Save current global values
void SaveAdjust()
{
	OldBrightness = Brightness;
	OldContrast = Contrast;
	OldSaturation = Saturation;
	OldGamma = Gamma;
	OldTemp = Temp;
	OldBlur = Blur;
	OldSharpness = Sharpness;
	OldSharpwidth = Sharpwidth;
	OldAdaptive = bAdaptive;
	OldFlip = bFlip;
	OldMirror = bMirror;
	OldSwap = bSwap;
}

// Restore globals from saved values
void RestoreAdjust()
{
	Brightness = OldBrightness;
	Contrast = OldContrast;
	Saturation = OldSaturation;
	Gamma = OldGamma;
	Temp = OldTemp;
	Blur = OldBlur;
	Sharpness = OldSharpness;
	Sharpwidth = OldSharpwidth;
	bAdaptive = OldAdaptive;
	bFlip = OldFlip;
	bMirror = OldMirror;
	bSwap = OldSwap;
}

// Reset adjust values to defaults
void ResetAdjust()
{
	Brightness = 0.0f; // -1 - 1 default 0
	Contrast   = 1.0f; //  0 - 2 default 1
	Saturation = 1.0f; //  0 - 4 default 1
	Gamma      = 1.0f; //  0 - 2 default 1
	Temp       = 6500.0f; // 3500 - 9500 default 6500 (daylight)
	Blur       = 0.0f; //  0 - 8 default 0
	Sharpness  = 0.0f; //  0 - 1 default 0
	Sharpwidth = 3.0f; //  3,5,7 default 3
	bAdaptive  = false;
	bFlip      = false;
	bMirror    = false;
	bSwap      = false;
}

void SetupDialogControls(HWND hDlg)
{

	char str1[MAX_PATH]{};

	HWND hBar = GetDlgItem(hDlg, IDC_BRIGHTNESS);
	SendMessage(hBar, TBM_SETRANGEMIN, (WPARAM)1, (LPARAM)0);
	SendMessage(hBar, TBM_SETRANGEMAX, (WPARAM)1, (LPARAM)400);
	SendMessage(hBar, TBM_SETPAGESIZE, (WPARAM)1, (LPARAM)20);
	// -1 > +1   - 0 - 200
	// pos + 1 * 100
	int iPos = (int)(Brightness + 1 * 200.0f);
	SendMessage(hBar, TBM_SETPOS, (WPARAM)1, (LPARAM)iPos);
	sprintf_s(str1, 256, "%.3f", Brightness);
	SetDlgItemTextA(hDlg, IDC_BRIGHTNESS_TEXT, (LPCSTR)str1);

	hBar = GetDlgItem(hDlg, IDC_CONTRAST);
	SendMessage(hBar, TBM_SETRANGEMIN, (WPARAM)1, (LPARAM)0);
	SendMessage(hBar, TBM_SETRANGEMAX, (WPARAM)1, (LPARAM)200);
	SendMessage(hBar, TBM_SETPAGESIZE, (WPARAM)1, (LPARAM)10);
	iPos = (int)(Contrast * 100.0f);
	SendMessage(hBar, TBM_SETPOS, (WPARAM)1, (LPARAM)iPos);
	sprintf_s(str1, 256, "%.3f", Contrast);
	SetDlgItemTextA(hDlg, IDC_CONTRAST_TEXT, (LPCSTR)str1);

	// 0 > 4  - 0 - 400
	hBar = GetDlgItem(hDlg, IDC_SATURATION);
	SendMessage(hBar, TBM_SETRANGEMIN, (WPARAM)1, (LPARAM)0);
	SendMessage(hBar, TBM_SETRANGEMAX, (WPARAM)1, (LPARAM)400);
	SendMessage(hBar, TBM_SETPAGESIZE, (WPARAM)1, (LPARAM)10);
	iPos = (int)(Saturation * 100.0f);
	SendMessage(hBar, TBM_SETPOS, (WPARAM)1, (LPARAM)iPos);
	sprintf_s(str1, 256, "%.3f", Saturation);
	SetDlgItemTextA(hDlg, IDC_SATURATION_TEXT, (LPCSTR)str1);

	hBar = GetDlgItem(hDlg, IDC_GAMMA);
	SendMessage(hBar, TBM_SETRANGEMIN, (WPARAM)1, (LPARAM)0);
	SendMessage(hBar, TBM_SETRANGEMAX, (WPARAM)1, (LPARAM)200);
	SendMessage(hBar, TBM_SETPAGESIZE, (WPARAM)1, (LPARAM)10);
	iPos = (int)(Gamma * 100.0f);
	SendMessage(hBar, TBM_SETPOS, (WPARAM)1, (LPARAM)iPos);
	sprintf_s(str1, 256, "%.3f", Gamma);
	SetDlgItemTextA(hDlg, IDC_GAMMA_TEXT, (LPCSTR)str1);

	hBar = GetDlgItem(hDlg, IDC_TEMPERATURE);
	SendMessage(hBar, TBM_SETRANGEMIN, (WPARAM)1, (LPARAM)3500);
	SendMessage(hBar, TBM_SETRANGEMAX, (WPARAM)1, (LPARAM)9500);
	SendMessage(hBar, TBM_SETPAGESIZE, (WPARAM)1, (LPARAM)10);
	iPos = (int)(Temp);
	SendMessage(hBar, TBM_SETPOS, (WPARAM)1, (LPARAM)iPos);
	sprintf_s(str1, 256, "%4.0f", Temp);
	SetDlgItemTextA(hDlg, IDC_TEMPERATURE_TEXT, (LPCSTR)str1);

	hBar = GetDlgItem(hDlg, IDC_SHARPNESS);
	SendMessage(hBar, TBM_SETRANGEMIN, (WPARAM)1, (LPARAM)0);
	SendMessage(hBar, TBM_SETRANGEMAX, (WPARAM)1, (LPARAM)100);
	SendMessage(hBar, TBM_SETPAGESIZE, (WPARAM)1, (LPARAM)10);
	iPos = (int)(Sharpness * 100.0f);
	SendMessage(hBar, TBM_SETPOS, (WPARAM)1, (LPARAM)iPos);
	sprintf_s(str1, 256, "%.3f", Sharpness);
	SetDlgItemTextA(hDlg, IDC_SHARPNESS_TEXT, (LPCSTR)str1);

	hBar = GetDlgItem(hDlg, IDC_BLUR);
	SendMessage(hBar, TBM_SETRANGEMIN, (WPARAM)1, (LPARAM)0);
	SendMessage(hBar, TBM_SETRANGEMAX, (WPARAM)1, (LPARAM)800);
	SendMessage(hBar, TBM_SETPAGESIZE, (WPARAM)1, (LPARAM)10);
	iPos = (int)(Blur * 100.0f);
	SendMessage(hBar, TBM_SETPOS, (WPARAM)1, (LPARAM)iPos);
	sprintf_s(str1, 256, "%.3f", Blur);
	SetDlgItemTextA(hDlg, IDC_BLUR_TEXT, (LPCSTR)str1);

	// Sharpness width radio buttons
	// 3x3, 5x5, 7x7
	iPos = ((int)Sharpwidth - 3) / 2; // 0, 1, 2
	CheckRadioButton(hDlg, IDC_SHARPNESS_3x3, IDC_SHARPNESS_7x7, IDC_SHARPNESS_3x3 + (int)iPos);

	// Adaptive sharpen checkbox
	if (bAdaptive)
		CheckDlgButton(hDlg, IDC_ADAPTIVE, BST_CHECKED);
	else
		CheckDlgButton(hDlg, IDC_ADAPTIVE, BST_UNCHECKED);

	// Option checkboxes
	if (bFlip)
		CheckDlgButton(hDlg, IDC_FLIP, BST_CHECKED);
	else
		CheckDlgButton(hDlg, IDC_FLIP, BST_UNCHECKED);
	if (bMirror)
		CheckDlgButton(hDlg, IDC_MIRROR, BST_CHECKED);
	else
		CheckDlgButton(hDlg, IDC_MIRROR, BST_UNCHECKED);
	if (bSwap)
		CheckDlgButton(hDlg, IDC_SWAP, BST_CHECKED);
	else
		CheckDlgButton(hDlg, IDC_SWAP, BST_UNCHECKED);
}

// That's all..
